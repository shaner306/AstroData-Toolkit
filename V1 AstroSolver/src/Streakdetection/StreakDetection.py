import os
import numpy as np
import numpy
from scipy import fft
from astropy.convolution import Gaussian2DKernel, convolve, convolve_fft
from astropy.io import fits
from astropy.stats import SigmaClip
from astropy.table import QTable
from astropy.stats import gaussian_fwhm_to_sigma
from photutils.background import Background2D
from photutils.background import SExtractorBackground
from photutils.segmentation import SourceCatalog
from photutils.segmentation import deblend_sources
from photutils.segmentation import detect_sources

from photutils.segmentation import make_source_mask

streak = r'/Users/home/Downloads/Landolt Fields/New Folder With Items'
streak2 = r'/Users/home/Downloads/2022-108-neossat-crosstalk-example'
streak1 = r'/Users/home/Downloads/2020_J107_Ottawa_IS901'
file_suffix = (".fits", ".fit", ".FIT", '.fts')
numFits = 0  # Number of images run through the Streak Detection

useMatchedFilter = False   # NOT WORKING - Experimental

# TODO Count fits not total files
# TODO Iterative matching based on results
# TODO Identify critical inputs

def make_kernal_line(angle, length, option=None):

    angle = numpy.deg2rad(angle)
    xsize = int(length * numpy.cos(angle))

    dx = int(numpy.ceil(length * max(np.abs(np.sin(angle)),
                                     np.cos(angle))))

    if dx % 2 == 0:
        dx += 1
    dy = dx
    linekernal = np.zeros((dx, dy), dtype=float)
    cx = (dx + 1) / 2
    cy = cx
    angle = angle.value
    if (angle > (0.7854) or angle < (-0.7854)):
        vertIncrement = np.cos(angle) / np.sin(angle)
        for j in range(dy):
            x = int(np.round(cx + (j - cy) * vertIncrement))

            linekernal[x][j] = 1
    else:
        horizIncrement = np.sin(angle) / np.cos(angle)
        for i in range(dx):
            y = int(np.round(cy + (i - cx) * horizIncrement))
            linekernal[i][y] = 1

    linekernal = linekernal / np.sum(np.sum(linekernal))
    return linekernal

def streak_detection(imageDir, sigma=5.0, streakLength=5, TRM=True, useMask=True):
    """
    Streak Detection algorithm - Takes in a directory of images and returns a table of the results

    Parameters
    ----------
    imageDir : str
        Directory of images to be run through the Streak Detection algorithm
    sigma : float
        Sigma cutoff value for the Streak Detection algorithm
    streakLength : int
        Minimum # of pixels of the source to be classified as a source/streak
    TRM : bool
        If True, will conduct source detection using raw fitsdata to detect streaks
        If False, will conduct source detection using the filtered/convolved data to detect circular sources
    useMask:
        If True, will use the mask generated by the Streak Detection algorithm to detect sources

    Returns
    -------
    tbl : astropy.table.QTable
        Table of the results of the Streak Detection algorithm

    """

    fluxSat = []
    xlocSat = []
    ylocSat = []
    imageSats = []
    # satelliteDetections = QTable([imageSats, xlocSat, ylocSat, fluxSat],
    #                             names=('Image', 'X Location (pixel)', 'Y Location (pixel)', 'Instrumental Magnitude'),
    #                             meta={'name': 'Satellite Detections'})
    numFits = 0
    for dirpath, dirnames, filenames in os.walk(imageDir):
        print(f'{len(filenames)} Files Detected')
        for filename in filenames:
            if (filename.endswith(file_suffix)):
                numFits += 1
                filepath = os.path.join(dirpath,
                                        filename)

                # Create .STARS (pinpoint) and .txt(astrometry) detection files
                STARS = open(filepath + '.stars', "w")
                AstrometryNetFile = open(filepath + '.txt', 'w')

                fitsdata = fits.open(filepath)[0].data
                sigma_clip = SigmaClip(sigma, maxiters=10)
                mask = make_source_mask(fitsdata, nsigma=sigma, npixels=10,
                                        dilate_size=11)
                bkg_estimator = SExtractorBackground()


                if TRM:
                    try:
                        bkg = Background2D(fitsdata, (30, 30), filter_size=(3, 3), mask=mask,
                                           bkg_estimator=bkg_estimator)
                    except:
                        bkg = SExtractorBackground(fitsdata)
                    threshold = bkg.background + (2.5 * bkg.background_rms)
                    kernel = Gaussian2DKernel(sigma, x_size=3, y_size=3)
                    convolved_data = convolve(fitsdata, kernel, normalize_kernel=True)
                    segm = detect_sources(fitsdata, threshold, npixels=streakLength)
                    segm_deblend = deblend_sources(fitsdata, segm, npixels=streakLength,
                                                   nlevels=50, contrast=0.0001)
                    cat = SourceCatalog(fitsdata, segm_deblend, convolved_data=None)

                else:
                    mask = make_source_mask(fitsdata, nsigma=sigma, npixels=5, dilate_size=11)
                    bkg = Background2D(fitsdata, (30, 30), filter_size=(3, 3),
                                       mask=mask, bkg_estimator=bkg_estimator)
                    threshold = bkg.background + (2.5 * bkg.background_rms)
                    # sigma = 5.5 * gaussian_fwhm_to_sigma  # FWHM = 3.
                    kernel = Gaussian2DKernel(sigma, x_size=3, y_size=3)
                    convolved_data = convolve(fitsdata, kernel, normalize_kernel=True)
                    segm = detect_sources(convolved_data, threshold, npixels=10)
                    segm_deblend = deblend_sources(convolved_data, segm, npixels=10,
                                                   nlevels=32, contrast=0.001)
                    cat = SourceCatalog(fitsdata, segm_deblend, convolved_data=convolved_data)

                tbl = cat.to_table()
                # print(str(len(tbl)) + "Sources Detected")

                if useMatchedFilter == True:
                    xmax = cat.bbox_xmax
                    xmin = cat.bbox_xmin
                    ymax = cat.bbox_ymax
                    ymin = cat.bbox_ymin
                    cenX = cat.xcentroid
                    cenY = cat.ycentroid
                    length = numpy.zeros((len(cenY), 1))
                    angles = cat.orientation
                    medangle = numpy.median(angles)
                    xsiz = len(fitsdata)
                    ysiz = len(fitsdata[0])

                    for i in range(len(xmax)):  # Calculate Length of streaks
                        x_length = xmax[i] - xmin[i]
                        y_length = ymax[i] - ymin[i]
                        length[i] = numpy.sqrt(x_length ** 2 + y_length ** 2)

                    medlen = numpy.median(length)

                    kernel = make_kernal_line(medangle, medlen)  # Create a matched filter
                    convolved_data = convolve_fft(fitsdata, kernel, normalize_kernel=True)
                    segm = detect_sources(convolved_data, threshold, npixels=10)
                    segm_deblend = deblend_sources(convolved_data, segm, npixels=10,
                                                   nlevels=32, contrast=0.001)
                    cat = SourceCatalog(fitsdata, segm_deblend, convolved_data=convolved_data)
                    tbl = cat.to_table()
                    print(cat.moments)

                for i in range(len(tbl['segment_flux'])):
                    streak_line = '{:.4f} {:.4f} 10 10 100 {:5.0f} 0 0.00'.format(float(tbl['xcentroid'][i]),
                                                                                  float(tbl['ycentroid'][i]),
                                                                                  tbl['segment_flux'][i])
                    STARS.write(streak_line + "\n")
                    if cat.eccentricity[i] < 0.5:
                        # satelliteDetections.append(filename, float(tbl['xcentroid'][i]), float(tbl['ycentroid'][i]),
                        #                           float(tbl['segment_flux'][i]))
                        print(
                            f"Potential satellite detected at {cat.xcentroid[i]:.3f}, "
                            f"{cat.ycentroid[i]:.3f} with a flux of "
                            f"{cat.segment_flux[i]} +/-{cat.segment_fluxerr[i]} ")

                tbl.sort('segment_flux', reverse=True)
                count = 0

                for i in range(len(tbl['xcentroid'])):
                    streak_line2 = '{:.4f} {:.4f} {:5.0f}'.format(float(tbl['xcentroid'][i]),
                                                          float(tbl['ycentroid'][i]),
                                                          tbl['segment_flux'][i])
                    AstrometryNetFile.write(streak_line2 + "\n")
                    count += 1

                print(f'{filename} index created.')
                print(f" {len(tbl['xcentroid'])} streaks detected.")
                STARS.close()
                AstrometryNetFile.close()

    if numFits == 0:
        print("No Valid Images Detected")
        return None

    elif TRM:
        # if len(satelliteDetections) == 0:
        # return "No valid satellite detections - Check images or adjust parameters. "
        # else:
        # return satelliteDetections
        return cat
    else:
        # return satelliteDetections
        return 0


def streak_detection_single(filepath, sigma=5.0, streakLength=5, TRM=True, useMask=True):
    """
    Streak Detection algorithm - Takes in a directory of images and returns a table of the results

    Parameters
    ----------
    imageDir : str
        Directory of images to be run through the Streak Detection algorithm
    sigma : float
        Sigma cutoff value for the Streak Detection algorithm
    streakLength : int
        Minimum # of pixels of the source to be classified as a source/streak
    TRM : bool
        If True, will conduct source detection using raw fitsdata to detect streaks
        If False, will conduct source detection using the filtered/convolved data to detect circular sources
    useMask:
        If True, will use the mask generated by the Streak Detection algorithm to detect sources

    Returns
    -------
    tbl : astropy.table.QTable
        Table of the results of the Streak Detection algorithm

    """

    fluxSat = []
    xlocSat = []
    ylocSat = []
    imageSats = []
    # satelliteDetections = QTable([imageSats, xlocSat, ylocSat, fluxSat],
    #                             names=('Image', 'X Location (pixel)', 'Y Location (pixel)', 'Instrumental Magnitude'),
    #                             meta={'name': 'Satellite Detections'})
    numFits = 0

    # Create .STARS (pinpoint) and .txt(astrometry) detection files
    STARS = open(filepath + '.stars', "w")
    AstrometryNetFile = open(filepath + '.txt', 'w')

    fitsdata = fits.open(filepath)[0].data
    sigma_clip = SigmaClip(sigma, maxiters=10)
    mask = make_source_mask(fitsdata, nsigma=sigma, npixels=10,
                            dilate_size=11)
    bkg_estimator = SExtractorBackground()


    if trm:
        try:
            bkg = Background2D(fitsdata, (30, 30), filter_size=(3, 3), mask=mask,
                                bkg_estimator=bkg_estimator)
        except:
            bkg = SExtractorBackground(fitsdata)
        threshold = bkg.background + (2.5 * bkg.background_rms)
        # print(threshold)
        kernel = Gaussian2DKernel(sigma, x_size=3, y_size=3)
        convolved_data = convolve(fitsdata, kernel, normalize_kernel=True)
        segm = detect_sources(fitsdata, threshold, npixels=streakLength)
        segm_deblend = deblend_sources(fitsdata, segm, npixels=streakLength,
                                        nlevels=50, contrast=0.0001)
        cat = SourceCatalog(fitsdata, segm_deblend, convolved_data=None)

    else:
        mask = make_source_mask(fitsdata, nsigma=sigma, npixels=5, dilate_size=11)
        bkg = Background2D(fitsdata, (30, 30), filter_size=(3, 3),
                            mask=mask, bkg_estimator=bkg_estimator)
        threshold = bkg.background + (2.5 * bkg.background_rms)
        # sigma = 5.5 * gaussian_fwhm_to_sigma  # FWHM = 3.
        kernel = Gaussian2DKernel(sigma, x_size=3, y_size=3)
        convolved_data = convolve(fitsdata, kernel, normalize_kernel=True)
        segm = detect_sources(convolved_data, threshold, npixels=10)
        segm_deblend = deblend_sources(convolved_data, segm, npixels=10,
                                        nlevels=32, contrast=0.001)
        cat = SourceCatalog(fitsdata, segm_deblend, convolved_data=convolved_data)
    FWHMlist = np.array(cat.fwhm[:])
    tbl = cat.to_table()
    # print(str(len(tbl)) + "Sources Detected")

    if useMatchedFilter == True:
        xmax = cat.bbox_xmax
        xmin = cat.bbox_xmin
        ymax = cat.bbox_ymax
        ymin = cat.bbox_ymin
        cenX = cat.xcentroid
        cenY = cat.ycentroid
        length = numpy.zeros((len(cenY), 1))
        angles = cat.orientation
        medangle = numpy.median(angles)
        xsiz = len(fitsdata)
        ysiz = len(fitsdata[0])

        for i in range(len(xmax)):  # Calculate Length of streaks
            x_length = xmax[i] - xmin[i]
            y_length = ymax[i] - ymin[i]
            length[i] = numpy.sqrt(x_length ** 2 + y_length ** 2)

        medlen = numpy.median(length)

        kernel = make_kernal_line(medangle, medlen)  # Create a matched filter
        convolved_data = convolve_fft(fitsdata, kernel, normalize_kernel=True)
        segm = detect_sources(convolved_data, threshold, npixels=10)
        segm_deblend = deblend_sources(convolved_data, segm, npixels=10,
                                        nlevels=32, contrast=0.001)
        cat = SourceCatalog(fitsdata, segm_deblend, convolved_data=convolved_data)
        FWHMlist = np.array(cat.fwhm[:])
        tbl = cat.to_table()

    for i in range(len(tbl['segment_flux'])):
        streak_line = '{:.4f} {:.4f} 10 10 100 {:5.0f} 0 0.00'.format(float(tbl['xcentroid'][i]),
                                                                        float(tbl['ycentroid'][i]),
                                                                        tbl['segment_flux'][i])
        STARS.write(streak_line + "\n")
        # if cat.eccentricity[i] < 0.5:
            # satelliteDetections.append(filename, float(tbl['xcentroid'][i]), float(tbl['ycentroid'][i]),
            #                           float(tbl['segment_flux'][i]))
            # print(
            #     f"Potential satellite detected at {cat.xcentroid[i]:.3f}, "
            #     f"{cat.ycentroid[i]:.3f} with a flux of "
            #     f"{cat.segment_flux[i]} +/-{cat.segment_fluxerr[i]} ")

    tbl.sort('segment_flux', reverse=True)
    count = 0

    for i in range(len(tbl['xcentroid'])):
        streak_line2 = '{:.4f} {:.4f}'.format(float(tbl['xcentroid'][i]),
                                                float(tbl['ycentroid'][i]))
        AstrometryNetFile.write(streak_line2 + "\n")
        count += 1

    # print(f'{filename} index created.')
    # print(f" {len(tbl['xcentroid'])} streaks detected.")
    STARS.close()
    AstrometryNetFile.close()

    return tbl, bkg.background, FWHMlist

    if numFits == 0:
        print("No Valid Images Detected")
        return None

    elif trm == True:
        # if len(satelliteDetections) == 0:
        # return "No valid satellite detections - Check images or adjust parameters. "
        # else:
        # return satelliteDetections
        return 0
    else:
        # return satelliteDetections
        return 0


def filter_sats_stars(tbl, ecct_cut=0.5):

    eccentricity = np.array(tbl['eccentricity'])
    possible_sats = tbl[eccentricity < ecct_cut]
    sat_x = np.array(possible_sats['xcentroid'])
    sat_y = np.array(possible_sats['ycentroid'])
    # print(tbl.columns)
    # print(sat_x)
    return sat_x, sat_y

# tbl, _, _ = streak_detection_single(r'/media/jmwawrow/Seagate Backup Plus Drive/Intelsat 10-02/2021-04-21 - unprocessed/April21/TRM/G/0328_3x3_-10.00_5.00_G_00-00-24.fits')
# filter_sats_stars(tbl)

